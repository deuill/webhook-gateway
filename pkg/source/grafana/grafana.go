package grafana

import (
	// Standard library.
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"text/template"

	// Internal packages.
	"go.deuill.org/webhook-gateway/pkg/gateway"
)

// A Payload represents the full request payload for Grafana WebHook notifications. By default,
// payloads can contain fully-formed notification messages, generated by templates set in Grafana
// itself; where these are missing or otherwise unnecessary, messages can be formed based on alert
// metadata included in the payload.
type Payload struct {
	Status      string  `json:"status"`
	Alerts      []Alert `json:"alerts"`
	ExternalURL string  `json:"externalURL"`

	GroupLabels       map[string]string `json:"groupLabels"`
	CommonLabels      map[string]string `json:"commonLabels"`
	CommonAnnotations map[string]string `json:"commonAnnotations"`

	State   string `json:"state"`
	Title   string `json:"title"`
	Message string `json:"message"`
}

// A Alert represents a single instance of an alert notification, whether active or resolved. Alert
// payloads typically contain additional metadata related to the circumstances of the originating
// event.
type Alert struct {
	Status      string            `json:"status"`
	Labels      map[string]string `json:"labels"`
	Annotations map[string]string `json:"annotations"`
	Values      map[string]string `json:"valueString"`

	StartsAt string `json:"startsAt"`
	EndsAt   string `json:"endsAt"`

	SilenceURL   string `json:"silenceURL"`
	DashboardURL string `json:"dashboardURL"`
	PanelURL     string `json:"panelURL"`
}

// Grafana represents a message source for Grafana WebHook contact points. For information on how
// incoming requests are parsed, check the documentation for [Grafana.ParseHTTP].
type Grafana struct {
	// Internal fields.
	template *template.Template
}

// New instantiates an instance of a [Grafana] source, for the options given.
func New(options ...Option) (*Grafana, error) {
	var g Grafana
	for _, fn := range options {
		if err := fn(&g); err != nil {
			return nil, err
		}
	}

	return &g, nil
}

// A Option represents any configuration provided to new instances of [Grafana] sources.
type Option func(*Grafana) error

// WithTemplate overrides the default, server-provided template for incoming alerts. The template
// given will be parsed according to rules defined in [text/template], an error being returned if
// the template given does not parse correctly.
func WithTemplate(t string) Option {
	return func(g *Grafana) error {
		tpl, err := template.New("message").Parse(t)
		if err != nil {
			return fmt.Errorf("failed parsing message template: %w", err)
		}

		g.template = tpl
		return nil
	}
}

// ParseHTTP processes the given HTTP request, parsing a standard Grafana WebHook payload.
//
// Incoming requests will have the 'Authorization' header checked for a correct 'Bearer' token
// corresponding secret configured at the gateway level.
//
// By default, notifications will be collected into a single [gateway.Message], using the title and
// content found in the payload itself; however, if a custom template has been configured, this will
// be used instead. If neither custom template nor payload-provided content is found, this function
// will return an error.
func (g *Grafana) ParseHTTP(r *http.Request) ([]*gateway.Message, error) {
	// Validate secret in HTTP headers.
	if secret := gateway.GetSecret(r.Context()); secret != "" {
		if h := r.Header.Get("Authorization"); h == "" {
			return nil, fmt.Errorf("Authorization header not found")
		} else if v, ok := strings.CutPrefix(h, "Bearer "); !ok || v != secret {
			return nil, fmt.Errorf("invalid Bearer token")
		}
	}

	// Try to read payload from incoming request.
	buf, err := io.ReadAll(r.Body)
	if err != nil {
		return nil, fmt.Errorf("failed reading request body: %w", err)
	}

	defer r.Body.Close()
	var payload Payload

	if err := json.Unmarshal(buf, &payload); err != nil {
		return nil, fmt.Errorf("failed parsing request: %w", err)
	}

	var msg gateway.Message

	// Prefer configured template over Grafana-provided default, if available.
	if g.template != nil {
		var buf bytes.Buffer
		if err := g.template.Execute(&buf, payload); err != nil {
			return nil, err
		}
		msg.Content = strings.TrimSpace(buf.String())
	} else if payload.Message != "" {
		if payload.Title != "" {
			msg.Content = payload.Title + "\n"
		}
		msg.Content += payload.Message
	} else {
		return nil, fmt.Errorf("no message content found")
	}

	return []*gateway.Message{&msg}, nil
}

// Init ensures the [Grafana] source is configured correctly, and initializes any sub-resources
// necessary for its operation.
func (g *Grafana) Init(_ context.Context) error {
	return nil
}

// UnmarshalTOML configures the [Grafana] source based on values sourced from TOML configuration.
func (g *Grafana) UnmarshalTOML(data any) error {
	conf, ok := data.(map[string]any)
	if !ok {
		return nil
	}

	if v, ok := conf["template"].(string); ok && v != "" {
		if err := WithTemplate(v)(g); err != nil {
			return err
		}
	}

	return nil
}

// Register Grafana source for gateway configuration.
func init() {
	initfn := func() gateway.Source { return &Grafana{} }
	gateway.RegisterSource("grafana", initfn)
}
